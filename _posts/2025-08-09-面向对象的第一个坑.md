---
# md文件名的时间仅做渲染标记, 页面在Blog上显示的时间以此处为准
layout:     post

# 大标题
title:      "面向对象的第一个坑"

# 小标题
subtitle:   ' 跨实例调用——依赖注入 '

# 时间
date:       2025-08-09 20:00:00

# 作者
author:     "Xiangmin Li"

# 标题背景图
header-img: "img/post-bg-2015.jpg"

# 右侧目录
catalog: true
#tags:
---
<!--------------------以下为页面正文---------------------->

# 面向对象的第一个坑——依赖注入

刚开始学习C#编程语言的时候，觉得很简单，就像大一学习Java的时候一样简单，但当学过了基本的语法学习后，第一个面向对象编程思想的坑就出现了——如何进行跨实例调用

### 如何进行跨实例调用

在面向过程编程里，比如C语言，它就没有class也就无从谈起实例化以及跨实例调用方法了，C语言可以简单的直接去调用一个方法，代码是顺序执行的，写代码的时候只需要关注代码的执行顺序就行了，但是C#编程需要考虑的就多了，要先给class实例化一个对象出来，然后再调用对象持有的方法，这一切的原因就是代码的静态和动态，那么跨实例调用所需要的信息就呼之欲出了，需要被调用的对象的引用地址，以及它持有的方法地址。

### 依赖注入(DI)

最简单的方法是使用**依赖注入**

```csharp


//创建一个类,其中有一个sayHello方法需要调用另一个类ToPrint中的hello方法
class TheFanc
{
    private ToPrint toPrint;
    public TheFanc(ToPrint _toPrint)//使用构造函数传入ToPrint的引用地址
    {
        toPrint = _toPrint;
    }
    public void sayHello() { 
        toPrint.hello();//跨实例调用
    }
}
//创建一个被依赖的类ToPrint
class ToPrint {
    public void hello() {
        Console.WriteLine("Hello World");
    }
}

internal class Program
{
    static void Main(string[] args)
    {
        var toPrint = new ToPrint();
        var theFanc = new TheFanc(toPrint);//传入对象toPrint的引用地址
        theFanc.sayHello();
    }
}

```

上面这段代码中,使用了**依赖注入**来进行跨实例的方法调用, 但是代码耦合度略高,可以使用**接口interface**解耦代码

### 代码解耦

**接口interface + 依赖注入**

```csharp

internal class Program
{
    static void Main(string[] args)
    {
        PlusTool plusTool = new PlusTool();
        OutTool outTool = new OnePlus(plusTool);//传递依赖
        int a = 0;
        outTool.toOut(a);//调用第一个实现
        outTool = new TwoPlus(plusTool);
        a = 0; 
        outTool.toOut(a);//调用第二个实现

    }
}

//创建被依赖的一个类
class PlusTool
{
    public int toPlus(int a)
    {
        a++;
        return a;
    }
}
//定义接口
interface OutTool
{
    void toOut(int a);
}
//实现接口,注入依赖
class OnePlus : OutTool
{
    //注入依赖
    private PlusTool _plusTool;
    public OnePlus(PlusTool plusTool)
    {
        _plusTool = plusTool;
    }

    
    public void toOut(int a)
    {
        Console.WriteLine(_plusTool.toPlus(a) );//调用1次toPlus()
    }
}
//另一种实现,注入依赖
class TwoPlus : OutTool {
    //注入依赖
    private PlusTool _plusTool;
    public TwoPlus(PlusTool plusTool)
    {
        _plusTool = plusTool;
    }

    
    public void toOut(int a)
    {
        Console.WriteLine(_plusTool.toPlus(_plusTool.toPlus(a)));//调用2次toPlus()
    }
}
```