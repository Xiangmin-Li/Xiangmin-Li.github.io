---
# md文件名的时间仅做渲染标记, 页面在Blog上显示的时间以此处为准
layout:     post

# 大标题
title:      "游戏设计模式——行为型"

# 小标题
subtitle:   ' Behavioral Patterns '

# 时间
date:       2025-08-12 20:02:00

# 作者
author:     "Xiangmin Li"

# 标题背景图
header-img: "img/post-bg-2015.jpg"

# 右侧目录
catalog: true
#tags:
---
<!--------------------以下为页面正文---------------------->



# 行为型（Behavioral Patterns）

## 字节码模式（Bytecode Pattern）

**字节码模式（Bytecode Pattern）是一种通过**中间指令集来驱动程序行为的模式。

**核心思想：**把需要执行的逻辑先编译成一组自定义的“指令码”（类似机器码，但由我们定义），然后在运行时由一个**虚拟机（解释器）**来逐条执行这些指令。

**这种方式在游戏中常用于：**

- 脚本系统（例如 NPC 对话、任务逻辑）
- 可下载的关卡逻辑
- AI 行为脚本
- 特效动画脚本

**字节码模式的组成结构：**

- **指令集（Instruction Set）**  定义所有可能的指令，例如`MOVE_FORWARD`、`PLAY_ANIMATION`、`WAIT` 等。
- **字节码（Bytecode）**  由一连串指令组成的序列，每条指令通常由操作码（opcode）+ 参数（operand）构成。
- **虚拟机（Virtual Machine）**  负责解释并执行字节码。

当我们在 Unity 项目中想让策划、美术或关卡设计师**不写 C# 代码也能编写游戏逻辑**时，可以用字节码模式来做一个**自定义脚本虚拟机**。

**典型应用场景：**

对话系统

- 关卡编辑器生成“对话脚本” → 编译成自定义字节码（例如 MOVE、WAIT、PLAY\_ANIM、SAY）
- 运行时用一个虚拟机组件解析执行这些字节码

技能系统

- 策划配置技能的帧动作（播放动画、生成特效、检测碰撞、造成伤害）
- 构建成字节码序列，由技能执行器解释执行

AI 行为树/状态机

- 编辑器把 AI 行为树保存成中间指令格式
- 游戏运行时逐步解释执行

任务/关卡逻辑

- 将触发条件与行为（开门、生成敌人、播放剧情）编译成字节码
- 运行时驱动整个关卡流程

## 子类沙盒模式（Subclass Sandbox Pattern）

**核心思想：**父类定义好一个“安全沙盒”框架，子类只能在这个框架内部的空白区域里自由发挥。

**子类沙盒模式很适合：**

- 流程**高度一致**（比如技能释放流程 = 消耗资源 → 播放动画 → 计算效果 → 应用效果）
- 细节差异**主要在个别步骤**（比如消耗多少资源、播放什么动画、计算公式不同）
- 希望**控制子类的行为范围**，防止乱改核心流程

**模式结构：**

父类（定义沙盒）

- 定义一个模板方法（固定执行流程）
- 提供一些受保护的工具方法（沙盒里的玩具）
- 留出抽象方法或空实现（沙盒空地）

子类（在沙盒里玩）

- 实现抽象方法
- 使用父类提供的工具方法
- 不允许改变流程顺序

## 类型对象模式（Type Object Pattern）

在游戏里，我们经常有这样一个需求：

- 游戏世界中有很多对象（怪物、武器、技能、道具……）。
- 它们的**类型很多**（史莱姆、哥布林、巨龙；短剑、长剑、魔法杖……）。
- 这些类型不仅数量庞大，而且可能**运行时还会新增、修改**（例如 DLC 或 MOD 增加新怪物类型）。
- 如果直接用**继承**，每种类型都建一个子类，会导致**类爆炸**，并且类型之间的组合变化很难灵活应对。

**核心思想：**把“类型”本身当作一个**可操作的对象**来存放数据，而不是用类继承硬编码。游戏对象不直接通过类来区分，而是通过引用它们的“类型对象”来决定行为和数据。

**游戏中的常见应用****：**

- RPG 怪物/武器/装备系统（类型全由数据驱动）
- 卡牌游戏（每张牌是实例，牌面效果是类型对象）
- 技能系统（技能实例引用技能类型）
- 建筑系统（RTS 中不同建筑用同一建筑类，不同类型对象配置）

**与享元模式的区别****：**

**享元模式**核心是**共享对象的内存数据**，减少重复存储（关注性能与内存优化）

**类型对象模式**核心是**将类型数据抽离成对象**，实现灵活的数据驱动（关注灵活性与可扩展性）

两者可以结合，类型对象本身可以被多个实例共享，从而也起到享元的作用。



