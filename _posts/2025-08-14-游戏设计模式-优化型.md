---
# md文件名的时间仅做渲染标记, 页面在Blog上显示的时间以此处为准
layout:     post

# 大标题
title:      "游戏设计模式——优化型"

# 小标题
subtitle:   ' Optimization Pattern '

# 时间
date:       2025-08-08 20:01:00

# 作者
author:     "Xiangmin Li"

# 标题背景图
header-img: "img/post-bg-2015.jpg"

# 右侧目录
catalog: true
#tags:
---
<!--------------------以下为页面正文---------------------->

# 优化型（Optimization Pattern）

## 数据局部性模式（Data Locality Pattern）

**核心思想：** 把游戏运行时需要一起处理的数据放在内存中连续存储，减少 CPU 去“翻硬盘找东西”的次数。

**为什么会有这个模式**

现代 CPU 的速度远比内存快很多（几十到上百倍），所以 CPU 在访问数据时会用**缓存（Cache）**来加速。

- **缓存命中（Cache Hit）**：要的数据已经在缓存中 → 很快。
- **缓存未命中（Cache Miss）**：要的数据不在缓存中，需要去主内存读 → 慢很多。

**数据局部性模式**就是通过设计数据结构，让需要一起访问的数据在物理内存中也是连续的，从而提升**缓存命中率**。

```text 
//这种方式在内存中存的是对象引用数组，每个 Enemy 对象分散在堆的不同位置。
//遍历敌人时，CPU 需要频繁跳到不同内存地址 → 缓存不友好。
class Enemy
{
    public Vector3 position;
    public Vector3 velocity;
    public int health;
    public AIState state;
}
Enemy[] enemies = new Enemy[1000];
//--------------------------------
struct EnemyData
{
    public float[] posX;
    public float[] posY;
    public float[] posZ;
    public float[] velX;
    public float[] velY;
    public float[] velZ;
    public int[] health;
    public int count;
}
//改成 数据导向设计（Data-Oriented Design, DOD）
//同类数据放在一个连续的数组中。
//遍历时，CPU 能一次性把一大块数据加载到缓存里。
//常见形式是 结构的数组（SoA, Structure of Arrays），而不是数组的结构（AoS, Array of Structures）。
```


## 脏标记模式（Dirty Flag Pattern）

**核心思想：**给数据加一个“脏”标记（Dirty Flag），当数据被修改时标记为脏；当需要用到结果时，先检查这个标记，如果是脏的才重新计算，否则直接用缓存的值。

**脏标记模式**是“只在需要时更新”的一种优化手段，适用于数据变化频率**低于**使用频率的场景。

在大型游戏引擎中（比如 Unity 的 UI 系统、动画系统、渲染系统），脏标记几乎是标配。

## 对象池模式（Object Pool Pattern）

**核心思想：**与其不停地`new`和`delete`，不如维护一个“对象仓库”，用完的对象放回仓库，下次需要时直接取出来再用。

**为什么需要它****：**

频繁创建/销毁的问题：

- 创建对象要分配内存（开销大，尤其是大对象）。
- 销毁对象会触发垃圾回收（在 C# 里会引发 GC，造成性能抖动）。
- 在高频场景（子弹发射、粒子生成、敌人刷新等）会导致帧率波动。

对象池的好处：

- **一次创建，多次复用**，大幅减少内存分配和 GC。
- 可以提前分配好对象，避免运行中卡顿。

**模式结构：**

```markdown 
[请求对象] → [对象池] → [返回可用对象]
[释放对象] → [对象池] → [存回备用列表]
```


- 对象池（Pool）：维护可用对象的集合。
- 获取对象（Acquire/Get）：从池里取一个对象，如果没有就新建。
- 释放对象（Release/Return）：用完后放回池子。

**对象池模式**是用**空间换时间**的经典优化手段。在高频对象创建/销毁场景中，它能显著提升游戏的稳定帧率。Unity、UE 等引擎都有内置或官方示例的对象池工具。

## 空间分区模式（Spatial Partition Pattern）

空间分区模式的目标是**通过将游戏世界划分为多个小区域**，让程序在处理空间相关逻辑（如碰撞检测、渲染、AI感知等）时，只需要关注**与目标相关的小范围对象集合**，从而避免遍历整个游戏对象列表，提升性能。

**游戏中的实际应用：**

- **Unity**：物理引擎底层使用 BroadPhase（网格 + 树结构）优化碰撞检测
- **Minecraft**：区块（Chunk）就是一种三维空间分区
- **射击游戏**：子弹、玩家、掩体的可见性计算
- **MOBA**：小兵/英雄的仇恨范围检测只针对附近单位

