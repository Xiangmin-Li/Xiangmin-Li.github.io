---
# md文件名的时间仅做渲染标记, 页面在Blog上显示的时间以此处为准
layout:     post

# 大标题
title:      "从委托到事件"

# 小标题
subtitle:   ' 其实就是用一个集合存储了对象和方法的引用 '

# 时间
date:       2025-08-09 20:01:00

# 作者
author:     "Xiangmin Li"

# 标题背景图
header-img: "img/post-bg-2015.jpg"

# 右侧目录
catalog: true
#tags:
---
<!--------------------以下为页面正文---------------------->

# delegate委托



**delegate是什么？**

delegate 是一种**类型**,它表示**指向方法的引用**，可以把方法当成变量传来传去。它保存了**方法地址 + 实例地址（如果是实例方法）**，因此能在运行时调用

委托delegate是一个类型,所以最好定义在和class同级的位置
<br>`delegate void MyDelegate(string msg);`
<br>使用这个语句定义一个参数为`string`类型、返回值为`void`的委托
<br>委托可以绑定多个方法，调用时会依次执行, 如果委托有返回值，多播调用只保留**最后一个方法**的返回值
<br>委托的参数和返回值必须与方法签名一致

上面这个委托在定义后, 编译器会生成一个类: 
```csharp
sealed class MyDelegate : System.MulticastDelegate
{
    public MyDelegate(object target, IntPtr method);//构造函数(方法的对象, 方法的内存地址)
    public virtual void Invoke(string msg);//一个方法, 用来执行这个委托
    public virtual IAsyncResult BeginInvoke(string msg, AsyncCallback callback, object @object);//同上, 只不过是异步执行
    public virtual void EndInvoke(IAsyncResult result);//配合上一行,等待异步执行完成并获取返回值
}

```

## 委托的派生关系
![delegate派生关系](/img/委托与事件/delegate派生关系.png)
# Action



Action类型派生自delegate类型, 是一个常用的委托类型,特点是返回void, 有非泛型 Action（无参数）和 Action<T1, T2, ...>（最多 16 个参数）。
```csharp
internal class Program
{


    static void Main(string[] args)
    {
        Program program = new Program();
        Test test = new Test();
        myclass myclass = new myclass();

        Action pr ;//创建一个Action,并把3个方法绑定进去
        pr = program.toPrintProgram;
        pr += test.toPrintTest;
        pr += myclass.toPrintMyclass;
        
        pr?.Invoke();//调用这个Action

        //我们看看这个pr里面放了哪些方法
        Delegate[] fancList = pr.GetInvocationList();
        foreach (var item in fancList)
        {
            Console.WriteLine(item.Method.Name);
        }

    }

    void toPrintProgram()
    {
        Console.WriteLine("Program Hello, World!");

    }

}

class Test
{
    public void toPrintTest()
    {
        Console.WriteLine("Test Hello, World!");
    }
    int a = 1;

}

class myclass
{
    public void toPrintMyclass()
    {
        Console.WriteLine("myclass Hello, World!");
    }



}
```
# Func

Func类型派生自delegate类型, 是一个常用的委托类型,用来表示**有返回值**的方法引用
<br>语法: `Func<参数1类型, 参数2类型, ..., 返回值类型>`
<br>**最后一个泛型参数** 永远是返回值类型，前面的泛型参数是方法参数类型
```csharp
Func<int, int, int>
//这行Func的定义和下面delegate的定义是一样的
delegate int MyDelegate(int x, int y);
```


# event修饰符
event 修饰符的作用主要是**对委托字段进行封装**，控制外部对这个委托的访问权限，提供一种安全的发布-订阅机制。
```csharp
internal class Program
{


    static void Main(string[] args)
    {
        var Myclass = new Myclass();

        Action pr;//这是一个正常的Action委托
        pr = Myclass.print;
        pr += Myclass.print;
        Myclass.PrintName(pr);//查看此时Action里面有哪些方法
        pr = delegate { };   //改变pr的值
        Myclass.PrintName(pr);//再次查看

        //使用event修饰符,event只能定义在类或结构体里面

        Myclass.pr2 += Myclass.print;
        //Myclass.pr2 = delegate { };  //被event修饰的pr2不能被直接访问, 只能通过+=或-=操作
        Myclass.pr2 -= Myclass.print;
        //Myclass.PrintName(Myclass.pr2);  //对pr2的读取都是不允许的
        
    }
}
class Myclass
{
    public event Action pr2 = delegate { };//event定义在这里
    public void print()
    {
        Console.WriteLine("Hello World");
    }
    public void PrintName(Delegate pr)//这个方法用于查看Action里面的方法名
    {
        Console.WriteLine($"里面的方法如下:");
        Delegate[] fancList = pr.GetInvocationList();
        foreach (var item in fancList)
        {
            Console.WriteLine(item.Method.Name);
        }
    }

}
```
# EventHandler

`EventHandler`也是派生自delegate类型, 它是.NET推荐的事件委托类型

**派生关系**
```
System.Object
   └── System.Delegate
        └── System.MulticastDelegate
               └── System.EventHandler
               └── System.EventHandler<TEventArgs>//泛型版本
```
**用法**
```csharp
//事件管理器-事件的拥有者-事件的触发者
class EventManager
{
    public event EventHandler<MyEventArgs> myEvent = delegate { };
    public void callEventHandler(string str) 
    {
        myEvent?.Invoke(this,new MyEventArgs(str));
    }
}

//          事件的订阅者- 事件的响应者
class DoSomething
{
    
    public void toPrintLog(object? sender , MyEventArgs e)
    {
        Console.WriteLine(e.printText);
    }
}

//自定义事件的参数类型
class MyEventArgs : EventArgs
{
    public string printText { get; set; }
    public MyEventArgs(string _printText)
    {
        printText = _printText;
    }
}


internal class Program
{
    static void Main(string[] args)
    {
        //实例化EventManager和DoSomething
        var EventManager = new EventManager();
        var DoSomething = new DoSomething();
        string str = "Hello World";

        //将toPrintLog方法订阅到myEvent事件上
        EventManager.myEvent += DoSomething.toPrintLog;

        //模拟事件管理器发出事件通知
        EventManager.callEventHandler(str);
    }
}

```
上面这段代码中`public event EventHandler<MyEventArgs> myEvent;`是标准的事件声明, 它的本质是对委托事件的封装, 这句代码大致上等价于下面这段代码
```csharp
private EventHandler<MyEventArgs> myEventField;

public event EventHandler<MyEventArgs> myEvent
{
    add
    {
        myEventField = (EventHandler<MyEventArgs>)Delegate.Combine(myEventField, value);
    }
    remove
    {
        myEventField = (EventHandler<MyEventArgs>)Delegate.Remove(myEventField, value);
    }
}
``` 