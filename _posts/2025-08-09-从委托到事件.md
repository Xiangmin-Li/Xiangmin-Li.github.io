---
# md文件名的时间仅做渲染标记, 页面在Blog上显示的时间以此处为准
layout:     post

# 大标题
title:      "从委托到事件"

# 小标题
subtitle:   ' 其实就是用一个集合存储了对象和方法的引用 '

# 时间
date:       2025-08-09 20:01:00

# 作者
author:     "Xiangmin Li"

# 标题背景图
header-img: "img/post-bg-2015.jpg"

# 右侧目录
catalog: true
#tags:
---
<!--------------------以下为页面正文---------------------->

# Action委托

![delegate派生关系](/img/委托与事件/delegate派生关系.png)

Action类型派生自delegate类型, 是一个常用的委托类型,特点是返回void, 有非泛型 Action（无参数）和 Action<T1, T2, ...>（最多 16 个参数）。
```csharp
internal class Program
{


    static void Main(string[] args)
    {
        Program program = new Program();
        Test test = new Test();
        myclass myclass = new myclass();

        Action pr ;//创建一个Action,并把3个方法绑定进去
        pr = program.toPrintProgram;
        pr += test.toPrintTest;
        pr += myclass.toPrintMyclass;
        
        pr?.Invoke();//调用这个Action

        //我们看看这个pr里面放了哪些方法
        Delegate[] fancList = pr.GetInvocationList();
        foreach (var item in fancList)
        {
            Console.WriteLine(item.Method.Name);
        }

    }

    void toPrintProgram()
    {
        Console.WriteLine("Program Hello, World!");

    }

}

class Test
{
    public void toPrintTest()
    {
        Console.WriteLine("Test Hello, World!");
    }
    int a = 1;

}

class myclass
{
    public void toPrintMyclass()
    {
        Console.WriteLine("myclass Hello, World!");
    }



}
```

# event修饰符
event 修饰符的作用主要是**对委托字段进行封装**，控制外部对这个委托的访问权限，提供一种安全的发布-订阅机制。
```csharp
internal class Program
{


    static void Main(string[] args)
    {
        var Myclass = new Myclass();

        Action pr;//这是一个正常的Action委托
        pr = Myclass.print;
        pr += Myclass.print;
        Myclass.PrintName(pr);//查看此时Action里面有哪些方法
        pr = delegate { };   //改变pr的值
        Myclass.PrintName(pr);//再次查看

        //使用event修饰符,event只能定义在类或结构体里面

        Myclass.pr2 += Myclass.print;
        //Myclass.pr2 = delegate { };  //被event修饰的pr2不能被直接访问, 只能通过+=或-=操作
        Myclass.pr2 -= Myclass.print;
        //Myclass.PrintName(Myclass.pr2);  //对pr2的读取都是不允许的
        
    }
}
class Myclass
{
    public event Action pr2 = delegate { };//event定义在这里
    public void print()
    {
        Console.WriteLine("Hello World");
    }
    public void PrintName(Delegate pr)//这个方法用于查看Action里面的方法名
    {
        Console.WriteLine($"里面的方法如下:");
        Delegate[] fancList = pr.GetInvocationList();
        foreach (var item in fancList)
        {
            Console.WriteLine(item.Method.Name);
        }
    }

}
```
