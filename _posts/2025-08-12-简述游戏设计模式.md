---
# md文件名的时间仅做渲染标记, 页面在Blog上显示的时间以此处为准
layout:     post

# 大标题
title:      "简述游戏设计模式"

# 小标题
subtitle:   ' Programming Patterns '

# 时间
date:       2025-08-12 20:00:00

# 作者
author:     "Xiangmin Li"

# 标题背景图
header-img: "img/post-bg-2015.jpg"

# 右侧目录
catalog: true
#tags:
---
<!--------------------以下为页面正文---------------------->



如果把**C# 编程语言**比作修仙世界的根本功法，那么**设计模式**就像修士施展的各类法术。
金丹期的大能，不仅要苦修功法、积累澎湃灵气，还要修习并磨炼法术，将灵气化为千变万化的攻击、防御与奇术。
同样，设计模式就是对编程语言的高阶应用，它让你能将代码的力量更高效、更巧妙地释放出来。

## 享元模式

核心思想: **用共享对象来减少内存占用，把不会变的部分（内在状态）提取出来共享，把会变的部分（外在状态）单独存储**。

在游戏里，我们经常有大量相似对象，比如地图上的草丛、子弹、粒子效果等——如果每个都单独存一份完整数据，就会浪费大量内存。享元模式的主要目标是**“节省内存 + 提高性能”**。

举例: 地图上的树木

假设地图里有 10 万棵树：

**不使用享元**：每棵树都存一份模型、材质、纹理，占用巨大内存。

**使用享元**：

- **内在状态**：同种树的 Mesh、材质（共享）
- **外在状态**：位置、旋转、缩放（单独存）

结果：10 万棵树共用一份模型和材质，只额外存储少量变动数据，内存占用骤降。

**适用场景**：

- 大量重复对象，且大部分数据相同。
- 对内存优化要求高的游戏（开放世界、大地图 MMO、RTS）。

## 命令模式

核心思想: **把一个操作（请求）封装成独立对象，让请求的发出者和执行者解耦，并且支持撤销、重做、排队等扩展功能。**

在游戏里，命令模式最大的好处就是**输入逻辑和执行逻辑分离**，方便做**回放、撤销、AI 模拟、网络同步**等功能。

举例: 输入系统

- **Invoker**：键盘/手柄输入管理器
- **Command**：攻击、移动、跳跃命令
- **Receiver**：玩家角色 &#x20;

  这样输入和角色行为彻底解耦，换角色或录制回放时不用改输入逻辑。

## 观察者模式

核心思想: 建立对象间的一对多依赖关系，当一个对象状态变化时，会自动通知所有依赖它的对象进行更新。

在游戏里，它的作用是**让系统之间低耦合地传递事件**，不用直接引用就能互相通信。

举例: 玩家血量变化

- **主题**：玩家对象（Player）
- **观察者**：UI 血条、受伤音效、受击特效、AI 仇恨系统
- 只要血量改变，玩家对象就通知所有观察者更新。

## 原型模式

核心思想: 通过复制（克隆）已有对象来创建新对象，避免从零开始创建，提升性能并简化对象生成过程。

在游戏开发里，尤其是需要大量相似对象时，比如怪物、子弹、道具，原型模式能节省初始化开销和代码复杂度。

举例:敌人复制

游戏里有多种敌人，生成时从一个基本模板克隆，减少重复初始化。

## 单例模式

核心思想: 确保某个类只有一个实例，并提供全局访问点。

游戏中有些管理器类（如音频管理、游戏状态管理、资源管理器）只需一个实例，且要随时能访问。单例保证不会意外创建多个实例导致冲突。方便各处代码统一访问，避免传递复杂引用。

适用场景:&#x20;

- 游戏中全局管理类，如音频管理器、UI管理器、数据管理器
- 只需要唯一实例的服务类
- 需要跨场景保持状态的对象

## 状态模式

核心思想: 允许一个对象在其内部状态改变时改变行为，对象看起来好像改变了类。

举例: 玩家或怪物的动作状态

- 不同状态对应不同动画、行为逻辑。
- 切换状态时，切换对应的状态对象。

状态模式非常适合处理游戏中各种“状态”切换问题，像角色行为、AI 决策、UI 状态等。



