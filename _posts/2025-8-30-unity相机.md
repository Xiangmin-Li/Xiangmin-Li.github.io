---
# md文件名的时间仅做渲染标记, 页面在Blog上显示的时间以此处为准
layout:     post

# 大标题
title:      "unity相机"

# 小标题
subtitle:   '   '

# 时间
date:       2025-08-30 20:00:00

# 作者
author:     "Xiangmin Li"

# 标题背景图
header-img: "img/post-bg-2015.jpg"

# 右侧目录
catalog: true
#tags:
---
<!--------------------以下为页面正文---------------------->



# 简单的第三人称相机的实现

```c# 
using System.Collections;
using System.Collections.Generic;
using System.Net;
using UnityEngine;

public class CameraController : MonoBehaviour
{
    [SerializeField] Transform followTarget;//跟随对象
    [SerializeField] float distance = 5;//跟随距离

    float rotationX;
    float rotationY;

    [SerializeField] float minVerticalAngle = -20;//最小倾角
    [SerializeField] float maxVerticalAngle = 30;//最大倾角

    [SerializeField] Vector2 framingOffset;//相机跟随点的偏移量
    [SerializeField] float rotationSpeedX = 2f;//鼠标速度X
    [SerializeField] float rotationSpeedY = 2f;//鼠标速度Y

    [SerializeField] bool invertX;//鼠标x轴翻转
    [SerializeField] bool invertY;//鼠标Y轴翻转

    //[SerializeField] float smoothSpeed = 0.125f;//相机跟随平滑度
    

    float invertMouseX;
    float invertMouseY;

    void Start()
    {
        Cursor.visible = false;//设置鼠标指针可见性=false
        Cursor.lockState = CursorLockMode.Locked;//锁定鼠标指针在屏幕中心

        transform.position = followTarget.position - new Vector3(0, 0, distance) + new Vector3(framingOffset.x, framingOffset.y);
        transform.rotation = followTarget.rotation;
    }


    void Update()
    {
        invertMouseX = (invertX) ? -1 : 1;//鼠标翻转的x值正负
        invertMouseY = (invertY) ? -1 : 1;//鼠标翻转的y值正负

        rotationX += Input.GetAxis("Mouse Y") * rotationSpeedY * invertMouseY;//沿X轴旋转相机=鼠标输入Y方向移动数值
        rotationX = Mathf.Clamp(rotationX, minVerticalAngle, maxVerticalAngle);//对上下视角倾角进行限制
        rotationY += Input.GetAxis("Mouse X") * rotationSpeedX * invertMouseX;//沿Y轴旋转相机=鼠标输入X方向移动数值

        distance += Input.GetAxis("Mouse ScrollWheel")*-2;//鼠标滚轮调整跟随距离
        distance = Mathf.Clamp(distance,1,10);//相机距离的远近限制

        var targetRotation = Quaternion.Euler(rotationX, rotationY, 0);//相机位移向量
        var focusPosition = followTarget.position + new Vector3(framingOffset.x, framingOffset.y);//相机跟随点偏移后的位置

        Vector3 smoothPosition = focusPosition - (targetRotation * new Vector3(0, 0, distance));//相机的坐标移动
        //transform.position = Vector3.Lerp(transform.position, smoothPosition,smoothSpeed);//给相机移动加上平滑
        transform.position = smoothPosition;//相机移动

        transform.rotation = targetRotation;//相机的视角偏转

    }
}
//第三人称相机的基本原理:

//基本上可以分为两个方面: 1-相机的空间位置移动, 2-相机的视角旋转

//让相机相对于玩家角色的坐标,这样相机就跟随角色了, 相机的参考系以角色坐标为原点

//再获取鼠标的移动值计算成一个欧拉角,把这个欧拉角和相机位置相乘,就让相机沿着以角色为原点的球面运动了

//然后说相机的旋转, 相机位置移动的时候其旋转角度是不变的,这不对, 我要做的是让相机始终看着角色

//这也很简单, 其实就是那个计算得到的欧拉角,相机在球面上移动的角度就是相机应该旋转的角度

//ok, 这样相机的移动和旋转就完成了
```


这样就实现了一个简单的第三人称相机脚本

但是, 仅仅这样还不够, 在实际的游戏开发中,几乎没有游戏是直接用这么简单的相机脚本, 游戏中玩家的视角是一个非常复杂的设计哲学, 仅仅在相机的移动方面,也可以说是运镜, 就有非常多的细节需要补充

所以, 我选择使用unity的Cinemachine包先行实现一个能用的且简单的相机系统, 后期看需求再替换为完全手动实现的相机控制系统

