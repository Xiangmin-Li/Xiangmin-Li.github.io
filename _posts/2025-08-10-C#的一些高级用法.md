---
# md文件名的时间仅做渲染标记, 页面在Blog上显示的时间以此处为准
layout:     post

# 大标题
title:      "C#的一些高级用法"

# 小标题
subtitle:   ' 继承 接口 泛型 '

# 时间
date:       2025-08-10 20:00:00

# 作者
author:     "Xiangmin Li"

# 标题背景图
header-img: "img/post-bg-2015.jpg"

# 右侧目录
catalog: true
#tags:
---
<!--------------------以下为页面正文---------------------->

# C#的一些高级知识

## 继承与多态

#### 继承

继承是指一个类（子类）可以**基于另一个类（父类、基类）进行扩展和复用**，自动拥有父类的属性和方法，还可以添加自己的新成员或重写父类的方法。

```csharp
public class Animal  // 父类（基类）
{
    public void Eat()
    {
        Console.WriteLine("动物吃东西");
    }
}

public class Dog : Animal  // Dog 继承自 Animal
{
    public void Bark()
    {
        Console.WriteLine("汪汪叫");
    }
}

//使用时
Dog dog = new Dog();
dog.Eat();   // 调用继承自 Animal 的方法
dog.Bark();  // 调用 Dog 自己的方法


```


C# 仅支持单继承，一个类只能继承一个直接父类, 可以多级继承, 子类不能访问父类的private私有成员，但可以访问public公共、protected保护成员等

#### 方法重写

当子类继承父类时，子类可以**重新定义父类中已经存在的方法实现**，这就是“方法重写”。

重写后的子类方法，会覆盖父类对应的方法实现，调用时会执行子类版本。

为什么要用方法重写？

不同子类对同一方法有不同的行为表现。子类可以根据自己的需求修改或扩展父类功能。在不修改父类代码的情况下改变行为。

```csharp 
class Animal
{
    public virtual void Speak()//父类方法必须用 virtual 修饰，表示“这个方法允许被重写”。
    {
        Console.WriteLine("动物叫声");
    }
}

class Dog : Animal
{
    public override void Speak()//子类重写方法时，使用 override 关键字。
    {
        Console.WriteLine("汪汪汪");
    }
}
```


virtual表示父类方法允许被重写, override 表示子类重写父类方法，提供新的实现

在子类方法中可使用base访问父类方法, base.Speak()

#### 多态

多态（Polymorphism）是面向对象编程的三大特性之一（另外两个是封装和继承）

意思是: **同一操作作用于不同的对象，可以有不同的行为表现。**

```csharp 
Animal animalDog = new Dog();//这就是多态的体现
animalDog.Speak(); // 调用的是 Dog 重写后的 Speak，输出“汪汪汪”

```


**继承**和**接口实现**的区别在于, 继承的设计目的是建立类之间的层次结构，强调“是一个(is-a)”的关系, 接口的设计目的是定义功能规范，强调“能做什么”的能力

而且, C#不支持类多继承（一个子类只能继承一个父类）, 但是接口是可以被多个类实现并且一个类可以实现多个接口

#### 抽象类

抽象类是一种不能被实例化的类，通常用来作为其他类的基类。

它可以包含**抽象方法**（没有实现的方法），也可以包含已经实现的普通方法。

抽象类强调“**模板和部分实现**”，子类必须继承它并实现所有抽象方法。

```csharp 
// 抽象类声明，用 abstract 修饰
public abstract class Animal
{
    // 抽象方法，没有方法体
    public abstract void Speak();

    // 普通方法，有默认实现
    public void Eat()
    {
        Console.WriteLine("动物在吃东西");
    }
}

// 继承抽象类的子类，必须实现抽象方法
public class Dog : Animal
{
    public override void Speak()
    {
        Console.WriteLine("汪汪汪");
    }
}

```


当父类方法为virtual时,子类**重写**的情况下, 调用子类的实现

当父类方法为virtual时, 子类**不重写**的情况下,调用父类的实现

当父类方法为abstract时, 子类**必须**重写, 调用子类实现

## 接口interface

#### 接口的定义与实现

过于简单, 不再赘述

#### 依赖倒置原则

简单的说就是：

不要让具体实现（细节）绑死高层业务逻辑（高层模块）

要让它们都依赖于抽象（接口或抽象类）

而不是高层模块直接依赖具体类

**面向接口编程，而不是面向实现编程**

## 泛型

#### 泛型类

写代码的时候先不指定数据类型, 等使用的时候再指定具体类型,  还是为了代码复用

```csharp 
public class MyGenericClass<T>//定义的时候使用T作为类型占位符
{
    private T data;

    public MyGenericClass(T value)
    {
        data = value;
    }

    public void ShowData()
    {
        Console.WriteLine(data);
    }
}
//使用的时候指定类型就行了
var obj1 = new MyGenericClass<int>(100);
obj1.ShowData();  // 输出：100

var obj2 = new MyGenericClass<string>("Hello");
obj2.ShowData();  // 输出：Hello

```


List\<T>就是一种典型的泛型类

#### 泛型方法

泛型方法是指**在方法定义时引入类型参数（类型占位符）**，这样方法在调用时可以针对不同类型灵活使用。

```csharp 
//交换两个变量的值
public void Swap<T>(ref T a, ref T b)//ref关键字的作用是使用变量的内存地址, 这个方法直接修改了a和b的值, 且不依赖具体类型
{
    T temp = a;
    a = b;
    b = temp;
}

```


#### 泛型约束

泛型约束指对T占位符的一些限制条件

```csharp 
public class MyClass<T> where T : BaseClass, IDisposable, new()
{
    // ...
}

```


where 关键字用来给T进行约束, 多个约束用逗号分隔, 先后顺序要写好, 1-基类约束（最多一个）,2-接口约束, 3-new()约束必须放最后(意思是必须有无参构造函数)


