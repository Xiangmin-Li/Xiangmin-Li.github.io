---
# md文件名的时间仅做渲染标记, 页面在Blog上显示的时间以此处为准
layout:     post

# 大标题
title:      "游戏设计模式——解耦型"

# 小标题
subtitle:   ' Decoupling Pattern '

# 时间
date:       2025-08-14 20:00:00

# 作者
author:     "Xiangmin Li"

# 标题背景图
header-img: "img/post-bg-2015.jpg"

# 右侧目录
catalog: true
#tags:
---
<!--------------------以下为页面正文---------------------->

# 解耦型（Decoupling Pattern）

## **组件模式**（Component Pattern）

**核心思想：** 游戏对象本身是一个空壳，所有功能都由可独立复用的组件组成，这些组件像积木一样可以自由组合、添加、移除。

**模式结构：**

```text 
[GameObject]
   ├── [TransformComponent]
   ├── [RenderComponent]
   ├── [PhysicsComponent]
   ├── [AIComponent]
   └── ...
```


- GameObject：只负责管理组件，不直接实现任何行为。
- Component：实现单一功能（渲染、物理、AI等）。
- 组件之间低耦合：每个组件只关注自己，不知道也不依赖其他组件的内部实现。

## 事件队列模式（Event Queue Pattern）

**核心思想：** 事件先放到一个队列里，等游戏主循环有空的时候再统一处理，这样可以避免即时调用造成的性能抖动和逻辑混乱。

**关键解耦点**：

1. **空间解耦**：事件发送者不需要知道谁会接收。
2. **时间解耦**：事件不一定要立刻执行，而是延迟到合适的时机处理（通常在`Update` 或帧末）。

**模式结构：**

```text 
[事件发送者] → [事件队列] → [事件管理器] → [事件监听者]
```


- 事件发送者：产生事件（如玩家按键、怪物死亡、UI按钮点击）。
- 事件队列：缓存事件，保证先进先出（FIFO）。
- 事件管理器：统一分发事件给订阅者。
- 事件监听者：对某类事件做出响应。

## 服务定位器模式（Service Locator Pattern）

**核心思想：** 我要某个服务，但我不关心它是怎么实现的，也不关心它是怎么创建的，只需要问服务定位器要就行。

**模式结构：**

```markdown 
[游戏对象/系统] → [服务定位器] → [具体服务实例]
```


- 服务（Service）：一个提供特定功能的模块，比如音频系统、日志系统、资源管理器、路径寻路器等。
- 服务定位器（Service Locator）：维护一个“服务注册表”，可以根据服务类型或名称找到对应的实例。
- 调用方（Client）：使用服务的任何地方，只需要调用定位器获取服务实例，而不需要直接创建或引用服务类。

**适用场景：**

- 小中型游戏，想快速集中管理全局服务。
- 有很多可替换实现的模块（如不同平台的声音库）。
- 不想在每个地方手动传依赖对象。


