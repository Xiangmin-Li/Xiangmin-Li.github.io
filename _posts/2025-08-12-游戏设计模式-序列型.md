---
# md文件名的时间仅做渲染标记, 页面在Blog上显示的时间以此处为准
layout:     post

# 大标题
title:      "游戏设计模式——序列型"

# 小标题
subtitle:   ' 序列型(Sequencing Patterns) '

# 时间
date:       2025-08-12 20:01:00

# 作者
author:     "Xiangmin Li"

# 标题背景图
header-img: "img/post-bg-2015.jpg"

# 右侧目录
catalog: true
#tags:
---
<!--------------------以下为页面正文---------------------->



# 序列型(Sequencing Patterns)

## 双缓冲模式(Double Buffering)

双缓冲是一种用来解决画面闪烁和撕裂问题的技术，它使用两个缓冲区交替工作：

- **前缓冲区（Front Buffer）**：当前正在显示给用户的图像数据。
- **后缓冲区（Back Buffer）**：用于绘制下一帧画面的缓冲区。

游戏或渲染系统在后台（后缓冲区）完成一帧画面的所有绘制后，将前后缓冲区交换，显示给用户。这样，用户始终看到完整且连贯的画面，避免了直接绘制时的中间状态闪烁。

**为什么需要双缓冲？**

直接在屏幕（前缓冲区）绘制时，由于绘制是逐步进行的，屏幕显示的画面会处于不完整状态，导致闪烁或图像撕裂。双缓冲让绘制和显示分离，只有绘制完成后才切换显示，有效避免这些问题。

**工作流程:**

- 程序开始绘制新帧时，将图像绘制到**后缓冲区**。
- 绘制完成后，交换前后缓冲区指针（或引用）。
- 屏幕显示切换到新的前缓冲区，即刚刚绘制完成的画面。
- 下一个绘制周期继续在新的后缓冲区绘制。

Unity引擎底层的渲染系统已经实现了双缓冲（甚至多缓冲）机制。

## 游戏循环模式(Game Loop Pattern)

游戏循环模式是游戏程序的核心执行模式，它负责**持续不断地运行游戏的更新和渲染过程**，保证游戏以固定或动态的帧率平稳运行。

简单来说，游戏循环就是一个死循环，游戏逻辑、输入处理、物理模拟、渲染等都在这个循环中反复执行。

游戏循环一般包含以下几个步骤：

1. **处理输入**  读取玩家输入（键盘、鼠标、手柄等）。
2. **更新游戏状态**  计算游戏逻辑，比如角色位置更新、AI决策、碰撞检测等。
3. **渲染画面**  把更新后的游戏状态绘制到屏幕上。
4. **时间控制**  维持游戏的帧率，确保循环按照预期速度运行。

游戏循环存在的意义是什么? 它为什么如此重要?

- **保证游戏实时响应**：不断更新和渲染，给玩家流畅的体验。
- **时间驱动**：让游戏中的事件和动画按时间正确推进。
- **统一入口**：所有游戏逻辑集中管理，方便维护和扩展。

**Unity中的游戏循环模式**

Unity封装了游戏循环，主要通过`MonoBehaviour` 的生命周期函数实现：

- `Update()` 每帧调用，处理逻辑更新。
- `FixedUpdate()` 固定时间步调用，处理物理计算。
- `LateUpdate()` 渲染前的最后更新。

Unity开发者只需关注这些函数，无需自己写死循环。

## 更新方法模式(Update Method Pattern)

**核心思想: **给游戏中的每个对象一个统一的`Update()`方法，让它在每一帧中根据时间推进自己的状态。

这种模式通常结合**游戏循环（Game Loop）**使用，游戏循环负责调用所有对象的`Update()`，让整个游戏世界同步演化。

**模式结构的主要组成**

1. **游戏对象（Game Object）**  每个对象都有自己的`Update(deltaTime)` 方法，用来更新自身状态。
2. **对象管理器（World / Scene / EntityManager）**  负责保存所有需要更新的对象，并在每帧调用它们的更新方法。
3. **游戏循环（Game Loop）**  在每一帧中调用对象管理器的更新逻辑。

**工作流程**

- 游戏循环开始新的一帧。
- 计算时间差`deltaTime`（当前帧与上一帧的时间差）。
- 遍历所有需要更新的对象，调用它们的`Update(deltaTime)` 方法。
- 每个对象内部根据`deltaTime` 进行位置、动画、AI、物理等逻辑更新。
- 进入渲染阶段。

**在Unity中的应用**

- Unity 的`MonoBehaviour.Update()`就是典型的**更新方法模式**实现。
- Unity会在每帧调用所有激活对象的`Update()`方法，并传入帧时间（通过`Time.deltaTime` 获取）。
- 如果对象很多（成千上万），需要考虑对象池、分帧更新、ECS（实体组件系统）来优化。


